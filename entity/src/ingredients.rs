//! `SeaORM` Entity. Generated by sea-orm-codegen 0.10.4
use std::collections::HashMap;
use std::sync::Arc;

use async_graphql::dataloader::*;
use async_graphql::*;
use itertools::Itertools;
use sea_orm::{entity::prelude::*, QueryOrder};
use serde::{Deserialize, Serialize};

use crate::ingredient_units;

#[derive(Debug, Clone, Copy, PartialEq, Eq, EnumIter, DeriveActiveEnum, Serialize, Deserialize, Enum)]
#[sea_orm(rs_type = "String", db_type = "String(Some(2))")]
pub enum Reference {
    #[sea_orm(string_value = "g")]
    G,
    #[sea_orm(string_value = "ml")]
    ML,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize, SimpleObject)]
#[sea_orm(table_name = "ingredients")]
#[graphql(complex, concrete(name = "Ingredient", params()))]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub name: String,
    pub reference: Reference,
    pub carbs: f64,
    pub fat: f64,
    pub proteins: f64,
    pub alc: f64,
    pub inserted_at: DateTime,
    pub updated_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::ingredient_units::Entity")]
    IngredientUnits,
    #[sea_orm(has_many = "super::steps_ingredients::Entity")]
    StepsIngridients,
}

impl Related<super::ingredient_units::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::IngredientUnits.def()
    }
}

impl Related<super::steps_ingredients::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::StepsIngridients.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

pub struct IngredientLoader {
    pub conn: DatabaseConnection,
}

#[derive(Clone, Eq, PartialEq, Hash)]
struct UnitId(pub i64);

#[ComplexObject]
impl Model {
    async fn units(&self, ctx: &Context<'_>) -> Result<Vec<ingredient_units::Model>> {
        let loader = ctx.data_unchecked::<DataLoader<IngredientLoader>>();
        let units = loader.load_one(UnitId(self.id)).await?;

        Ok(units.unwrap_or_default())
    }

    async fn calories(&self) -> f64 {
        self.alc * 7.1 + self.carbs * 4.1 + self.fat * 9.3 + self.proteins * 4.1
    }
}

#[async_trait::async_trait]
impl Loader<UnitId> for IngredientLoader {
    type Value = Vec<ingredient_units::Model>;
    type Error = Arc<sea_orm::error::DbErr>;

    async fn load(&self, keys: &[UnitId]) -> Result<HashMap<UnitId, Self::Value>, Self::Error> {
        let ids = keys.iter().map(|k| k.0).collect_vec();

        let units = ingredient_units::Entity::find()
            .filter(ingredient_units::Column::IngredientId.is_in(ids))
            .order_by_asc(ingredient_units::Column::IngredientId)
            .order_by_asc(ingredient_units::Column::Id)
            .into_model::<ingredient_units::Model>()
            .all(&self.conn)
            .await?;

        let map = units
            .into_iter()
            .group_by(|unit| unit.ingredient_id)
            .into_iter()
            .map(|(key, group)| (UnitId(key), group.collect()))
            .collect();

        Ok(map)
    }
}
