//! `SeaORM` Entity. Generated by sea-orm-codegen 0.10.4

use std::collections::HashMap;
use std::sync::Arc;

use async_graphql::dataloader::*;
use async_graphql::*;
use sea_orm::entity::prelude::*;
use sea_orm::sea_query::Expr;
use sea_orm::QuerySelect;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize, SimpleObject)]
#[sea_orm(table_name = "tags")]
#[graphql(complex, concrete(name = "Tag", params()))]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub name: Option<String>,
    pub inserted_at: DateTime,
    pub updated_at: DateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::recipes_tags::Entity")]
    RecipesTags,
}

impl Related<super::recipes_tags::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RecipesTags.def()
    }
}

impl Related<super::recipes::Entity> for Entity {
    fn to() -> RelationDef {
        super::recipes_tags::Relation::Recipes.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::recipes_tags::Relation::Tags.def().rev())
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[ComplexObject]
impl Model {
    pub async fn recipes_count(&self, ctx: &Context<'_>) -> Result<i64> {
        let loader = ctx.data_unchecked::<DataLoader<TagsLoader>>();

        Ok(loader.load_one(self.id).await?.unwrap_or(0))
    }
}

pub struct TagsLoader {
    pub conn: DatabaseConnection,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]
enum CntResult {
    TagId,
    Cnt,
}

#[async_trait::async_trait]
impl Loader<i64> for TagsLoader {
    type Value = i64;
    type Error = Arc<sea_orm::error::DbErr>;

    async fn load(&self, keys: &[i64]) -> Result<HashMap<i64, Self::Value>, Self::Error> {
        let ids = keys.to_vec();

        let counts = super::recipes_tags::Entity::find()
            .filter(super::recipes_tags::Column::RecipeId.is_in(ids))
            .select_only()
            .column(super::recipes_tags::Column::TagId)
            .column_as(Expr::col(super::recipes_tags::Column::RecipeId).count(), "cnt")
            .group_by(super::recipes_tags::Column::TagId)
            .into_values::<_, CntResult>()
            .all(&self.conn)
            .await?;

        let mut map = HashMap::new();

        for (id, cnt) in counts {
            map.insert(id, cnt);
        }

        Ok(map)
    }
}
