//! `SeaORM` Entity. Generated by sea-orm-codegen 0.10.4

use std::collections::HashMap;
use std::sync::Arc;

use async_graphql::dataloader::*;
use async_graphql::*;
use itertools::Itertools;
use sea_orm::entity::prelude::*;
use sea_orm::{DatabaseConnection, FromQueryResult, JoinType, QuerySelect};
use serde::{Deserialize, Serialize};

use crate::{recipes_tags, steps, tags};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize, SimpleObject)]
#[sea_orm(table_name = "recipes")]
#[graphql(complex, concrete(name = "Recipe", params()))]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub name: String,
    #[sea_orm(column_type = "Text", nullable)]
    pub description: Option<String>,
    pub owner_id: Option<i64>,
    pub inserted_at: DateTime,
    pub updated_at: DateTime,
    pub image: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::steps::Entity")]
    Steps,
    #[sea_orm(has_many = "super::recipes_tags::Entity")]
    RecipesTags,
    #[sea_orm(
        belongs_to = "super::users::Entity",
        from = "Column::OwnerId",
        to = "super::users::Column::Id",
        on_update = "Cascade",
        on_delete = "SetNull"
    )]
    Users,
}

impl Related<super::steps::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Steps.def()
    }
}

impl Related<super::recipes_tags::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RecipesTags.def()
    }
}

impl Related<super::users::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Users.def()
    }
}

impl Related<super::tags::Entity> for Entity {
    fn to() -> RelationDef {
        super::recipes_tags::Relation::Tags.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::recipes_tags::Relation::Recipes.def().rev())
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Clone, Eq, PartialEq, Hash)]
struct TagId(pub i64);
#[derive(Clone, Eq, PartialEq, Hash)]
struct StepId(i64);

#[ComplexObject]
impl Model {
    async fn tags(&self, ctx: &Context<'_>) -> Result<Vec<tags::Model>> {
        let loader = ctx.data_unchecked::<DataLoader<RecipesLoader>>();
        let name: Option<Vec<tags::Model>> = loader.load_one(TagId(self.id)).await?;
        name.ok_or_else(|| "Not found".into())
    }

    async fn steps(&self, ctx: &Context<'_>) -> Result<Vec<steps::Model>> {
        let loader = ctx.data_unchecked::<DataLoader<RecipesLoader>>();
        let steps: Option<Vec<steps::Model>> = loader.load_one(StepId(self.id)).await?;
        steps.ok_or_else(|| "Not found".into())
    }
}

pub struct RecipesLoader {
    pub conn: DatabaseConnection,
}

#[derive(FromQueryResult)]
struct RecipeIdAndTag {
    pub recipe_id: i64,
    pub name: Option<String>,
    pub id: i64,
    pub inserted_at: DateTime,
    pub updated_at: DateTime,
}

#[async_trait::async_trait]
impl Loader<TagId> for RecipesLoader {
    type Value = Vec<tags::Model>;
    type Error = Arc<sea_orm::error::DbErr>;

    async fn load(&self, keys: &[TagId]) -> Result<HashMap<TagId, Self::Value>, Self::Error> {
        let ids = keys.iter().map(|k| k.0).collect_vec();
        let tags = tags::Entity::find()
            .join(JoinType::InnerJoin, tags::Relation::RecipesTags.def())
            .column_as(recipes_tags::Column::RecipeId, "recipe_id")
            .filter(recipes_tags::Column::RecipeId.is_in(ids))
            .into_model::<RecipeIdAndTag>()
            .all(&self.conn)
            .await?;

        let map = tags
            .into_iter()
            .group_by(|tag| tag.recipe_id)
            .into_iter()
            .map(|(key, group)| {
                let tags = group
                    .into_iter()
                    .map(|tag| tags::Model {
                        id: tag.id,
                        name: tag.name,
                        inserted_at: tag.inserted_at,
                        updated_at: tag.updated_at,
                    })
                    .collect();

                (TagId(key), tags)
            })
            .collect();

        Ok(map)
    }
}

#[async_trait::async_trait]
impl Loader<StepId> for RecipesLoader {
    type Value = Vec<steps::Model>;
    type Error = Arc<sea_orm::error::DbErr>;

    async fn load(&self, keys: &[StepId]) -> Result<HashMap<StepId, Self::Value>, Self::Error> {
        let ids = keys.iter().map(|k| k.0).collect_vec();

        let steps = steps::Entity::find()
            .filter(steps::Column::RecipeId.is_in(ids))
            .into_model::<steps::Model>()
            .all(&self.conn)
            .await?;

        let map = steps
            .into_iter()
            .group_by(|step| step.recipe_id)
            .into_iter()
            .map(|(key, group)| (StepId(key), group.collect()))
            .collect();

        Ok(map)
    }
}
